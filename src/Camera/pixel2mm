import cv2
import numpy as np
import os
import warnings
import pandas as pd
import matplotlib.pyplot as plt

# Read image
img = cv2.imread("goProHero10/src/Camera/images/linear/img_0000.png")

# Convert image to grayscale
img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Convert images to binary for paper detection
_, img_bin = cv2.threshold(img_gray, 160, 255, cv2.THRESH_BINARY)

# Opening binary image to remove noise around the paper
close_kernel = np.ones((9,9), np.uint8)
img_dilated = cv2.dilate(img_bin, close_kernel, iterations=1)
img_closed = cv2.erode(img_dilated, close_kernel, iterations=1)

# Find paper contour
image_contours, _ = cv2.findContours(img_closed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Find the largest contour that should be the paper
largest_contour = max(image_contours, key=cv2.contourArea)

# Approximate the contour with a 4-sided polygon
epsilon = 0.1 * cv2.arcLength(largest_contour, True)
approx = cv2.approxPolyDP(largest_contour, epsilon, True)

# Define the coordinates of the paper's vertices
top_left = approx[1][0]
bottom_left = approx[2][0]
bottom_right = approx[3][0]
top_right = approx[0][0]
paper_coords = np.float32([top_left, top_right, bottom_right, bottom_left])

# Define the coordinates of the rectangle's vertices
dst_height = max(np.linalg.norm(top_left-bottom_left), np.linalg.norm(bottom_right-top_right))
dst_width = dst_height * 297/210

rectangle_coords = np.float32([top_left, top_left + [dst_width, 0], top_left + [dst_width, dst_height], top_left + [0, dst_height]])

# Calculate the perspective transform matrix
transform_matrix = cv2.getPerspectiveTransform(paper_coords, rectangle_coords)

print("Transformation Matrix:")
print(transform_matrix)

pixel_to_mm = dst_height/210.0
print("Pixel to milimeter ratio =", pixel_to_mm, "pixel/mm")

def find_circle(img):
    # Convert image to gray
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # Convert image to binary for white circle detection
    _, img_bin = cv2.threshold(gray, 160, 255, cv2.THRESH_BINARY)

    # Opening binary image to remove noise around the circles
    close_kernel = np.ones((9, 9), np.uint8)
    img_dilated = cv2.dilate(img_bin, close_kernel, iterations=1)
    img_closed = cv2.erode(img_dilated, close_kernel, iterations=1)

    # Find circles using Hough Circle Transform
    circles = cv2.HoughCircles(
        img_closed, 
        cv2.HOUGH_GRADIENT, 
        dp=1, 
        minDist=20, 
        param1=50, 
        param2=30, 
        minRadius=0, 
        maxRadius=0
    )

    # List to store the centers of the circles
    centers = []

    # If circles are detected, draw them on the original image and store the centers
    if circles is not None:
        circles = np.uint16(np.around(circles))
        for i in circles[0, :]:
            center = (i[0], i[1])
            centers.append(center)
            # Draw the outer circle
            cv2.circle(img, center, i[2], (0, 255, 0), 2)
            # Draw the center of the circle
            cv2.circle(img, center, 2, (0, 0, 255), 3)
    
    return img, centers

